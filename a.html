<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <title>Cesium æ‰‡å½¢åŠ¨ç”»ï¼ˆä»…å¤–åœ†å¼§è½®å»“ï¼‰</title>
  <link
    rel="stylesheet"
    href="https://cdn.jsdelivr.net/npm/cesium@1.136/Build/Cesium/Widgets/widgets.css"
  />
  <script src="https://cdn.jsdelivr.net/npm/cesium@1.136/Build/Cesium/Cesium.js"></script>
  <style>
    html, body, #cesiumContainer {
      width: 100%;
      height: 100%;
      margin: 0;
      padding: 0;
      overflow: hidden;
    }
  </style>
</head>
<body>
<div id="cesiumContainer"></div>

<script>
  /*************************
   * 1ï¸âƒ£ Viewer åˆå§‹åŒ–
   *************************/
  const viewer = new Cesium.Viewer('cesiumContainer', {
    timeline: false,
    animation: false,
    geocoder: false,
    homeButton: false,
    sceneModePicker: false,
    baseLayerPicker: false,
    navigationHelpButton: false,
    terrainProvider: undefined
  });

  /*************************
   * 2ï¸âƒ£ å‚æ•°é…ç½®
   *************************/
  const config = {
    centerLng: 116.404,
    centerLat: 39.915,
    radius: 3000,                 // ç±³
    startAngle: 0,                // èµ·å§‹è§’åº¦ï¼ˆå¼§åº¦ï¼‰
    initAngle: Math.PI * 2,       // åˆå§‹æ•´åœ†
    targetAngle: Math.PI,         // åŠåœ†
    angleStep: 0.02,              // åŠ¨ç”»æ­¥é•¿
    delay: 1500,
    fillColor: Cesium.Color.RED.withAlpha(0.5),
    outlineColor: Cesium.Color.BLACK,
    outlineWidth: 2
  };

  let currentAngle = config.initAngle;
  let running = false;

  /*************************
   * 3ï¸âƒ£ æ‰‡å½¢ Polygon ç‚¹ï¼ˆå¡«å……ç”¨ï¼‰
   *************************/
  function buildSectorPositions(lng, lat, radius, start, end) {
    const positions = [];
    const step = Cesium.Math.toRadians(2);
    const metersPerDegree = 111000;

    // ä¸­å¿ƒç‚¹
    positions.push(
      Cesium.Cartesian3.fromDegrees(lng, lat, 0)
    );

    for (let angle = start; angle <= end; angle += step) {
      const dx = Math.cos(angle) * radius;
      const dy = Math.sin(angle) * radius;

      positions.push(
        Cesium.Cartesian3.fromDegrees(
          lng + dx / metersPerDegree,
          lat + dy / metersPerDegree,
          0
        )
      );
    }

    return positions;
  }

  /*************************
   * 4ï¸âƒ£ å¤–åœ†å¼§ Polyline ç‚¹ï¼ˆè½®å»“ç”¨ï¼‰
   *************************/
  function buildArcPositions(lng, lat, radius, start, end) {
    const positions = [];
    const step = Cesium.Math.toRadians(2);
    const metersPerDegree = 111000;

    for (let angle = start; angle <= end; angle += step) {
      const dx = Math.cos(angle) * radius;
      const dy = Math.sin(angle) * radius;

      positions.push(
        Cesium.Cartesian3.fromDegrees(
          lng + dx / metersPerDegree,
          lat + dy / metersPerDegree,
          0
        )
      );
    }

    return positions;
  }

  /*************************
   * 5ï¸âƒ£ å¡«å……æ‰‡å½¢ï¼ˆPolygonï¼‰
   *************************/
  const sectorEntity = viewer.entities.add({
    polygon: {
      hierarchy: new Cesium.CallbackProperty(() => {
        return new Cesium.PolygonHierarchy(
          buildSectorPositions(
            config.centerLng,
            config.centerLat,
            config.radius,
            config.startAngle,
            currentAngle
          )
        );
      }, false),
      material: config.fillColor,
      outline: false,
      height: 10,
      heightReference: Cesium.HeightReference.CLAMP_TO_GROUND
    }
  });

  /*************************
   * 6ï¸âƒ£ å¤–åœˆè½®å»“ï¼ˆPolylineï¼‰
   *************************/
  const arcOutline = viewer.entities.add({
    polyline: {
      positions: new Cesium.CallbackProperty(() => {
        return buildArcPositions(
          config.centerLng,
          config.centerLat,
          config.radius,
          config.startAngle,
          currentAngle
        );
      }, false),
      width: config.outlineWidth,
      material: config.outlineColor,
      clampToGround: true
    }
  });

  /*************************
   * 7ï¸âƒ£ åŠ¨ç”»é€»è¾‘
   *************************/
  function tick() {
    if (!running) return;

    if (currentAngle > config.targetAngle) {
      currentAngle = Math.max(
        currentAngle - config.angleStep,
        config.targetAngle
      );

      console.log(
        'å½“å‰è§’åº¦ï¼š',
        (currentAngle * 180 / Math.PI).toFixed(1) + 'Â°'
      );
    } else {
      running = false;
      viewer.clock.onTick.removeEventListener(tick);
      console.log('âœ… åŠ¨ç”»å®Œæˆ');
    }
  }

  /*************************
   * 8ï¸âƒ£ å¯åŠ¨æµç¨‹
   *************************/
  viewer.zoomTo(
    sectorEntity,
    new Cesium.HeadingPitchRange(
      0,
      -0.5,
      config.radius * 3
    )
  ).then(() => {
    setTimeout(() => {
      running = true;
      viewer.clock.onTick.addEventListener(tick);
      console.log('ğŸ¬ åŠ¨ç”»å¼€å§‹');
    }, config.delay);
  });
</script>
</body>
</html>
